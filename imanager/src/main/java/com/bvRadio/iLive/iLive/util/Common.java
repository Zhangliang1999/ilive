package com.bvRadio.iLive.iLive.util;import java.util.Random;public class Common {	public static final String JCH_CHARSET = "UTF-8";	public static final String JC_KEY = null;	public static String md5(String arg0) {		return Md5Util.encode(arg0);	}	public static int intval(String s) {		return intval(s, 10);	}	public static int intval(String s, int radix) {		if (s == null || s.length() == 0) {			return 0;		}		if (radix == 0) {			radix = 10;		} else if (radix < Character.MIN_RADIX) {			return 0;		} else if (radix > Character.MAX_RADIX) {			return 0;		}		int result = 0;		int i = 0, max = s.length();		int limit;		int multmin;		int digit;		boolean negative = false;		if (s.charAt(0) == '-') {			negative = true;			limit = Integer.MIN_VALUE;			i++;		} else {			limit = -Integer.MAX_VALUE;		}		if (i < max) {			digit = Character.digit(s.charAt(i++), radix);			if (digit < 0) {				return 0;			} else {				result = -digit;			}		}		multmin = limit / radix;		while (i < max) {			digit = Character.digit(s.charAt(i++), radix);			if (digit < 0) {				break;			}			if (result < multmin) {				result = limit;				break;			}			result *= radix;			if (result < limit + digit) {				result = limit;				break;			}			result -= digit;		}		if (negative) {			if (i > 1) {				return result;			} else {				return 0;			}		} else {			return -result;		}	}	public static String authCode(String string, String operation, String key, int expiry) {		long currentTime = System.currentTimeMillis();		int time = (int) (currentTime / 1000);		try {			int ckey_length = 4;			key = md5((key == null ? JC_KEY : key));			String keya = md5(key.substring(0, 16));			String keyb = md5(key.substring(16, 32));			String keyc = ckey_length > 0					? ("DECODE".equals(operation) ? string.substring(0, ckey_length) : md5(String.valueOf(currentTime)).substring(32 - ckey_length))					: "";			String cryptkey = keya + md5(keya + keyc);			int key_length = cryptkey.length();			string = "DECODE".equals(operation) ? Base64.decode(string.substring(ckey_length), JCH_CHARSET)					: (expiry > 0 ? expiry + time : "0000000000") + md5(string + keyb).substring(0, 16) + string;			int string_length = string.length();			StringBuffer result = new StringBuffer(string_length);			int range = 128;			int[] rndkey = new int[range];			for (int i = 0; i < range; i++) {				rndkey[i] = cryptkey.charAt(i % key_length);			}			int tmp;			int[] box = new int[range];			for (int i = 0; i < range; i++) {				box[i] = i;			}			for (int i = 0, j = 0; i < range; i++) {				j = (j + box[i] + rndkey[i]) % range;				tmp = box[i];				box[i] = box[j];				box[j] = tmp;			}			for (int a = 0, i = 0, j = 0; i < string_length; i++) {				a = (a + 1) % range;				j = (j + box[a]) % range;				tmp = box[a];				box[a] = box[j];				box[j] = tmp;				result.append((char) ((int) string.charAt(i) ^ (box[(box[a] + box[j]) % range])));			}			if ("DECODE".equals(operation)) {				int resulttime = Common.intval(result.substring(0, 10));				if ((resulttime == 0 || resulttime - time > 0)						&& result.substring(10, 26).equals(md5(result.substring(26) + keyb).substring(0, 16))) {					return result.substring(26);				} else {					return "";				}			} else {				return keyc + (Base64.encode(result.toString(), JCH_CHARSET)).replaceAll("=", "");			}		} catch (Exception e) {			return "";		}	}	/**	 * 获取指定长度的随机字符串	 * 	 * @param length	 * @return	 */	public static String getRandomString(int length) {		String base = "abcdefghijklmnopqrstuvwxyz0123456789";		Random random = new Random();		StringBuffer sb = new StringBuffer();		for (int i = 0; i < length; i++) {			int number = random.nextInt(base.length());			sb.append(base.charAt(number));		}		return sb.toString();	}	/**	 * 随机指定范围内N个不重复的数 最简单最基本的方法	 * 	 * @param min	 *            指定范围最小值	 * @param max	 *            指定范围最大值	 * @param n	 *            随机数个数	 */	public static Integer[] getRandomArray(int min, int max, int n) {		if (n >= (max - min + 1) || max < min) {			n=max - min;		}		Integer[] result = new Integer[n];		Integer count = 0;		while (count < n) {			Integer num = (int) (Math.random() * (max - min)) + min;			boolean flag = true;			for (Integer j = 0; j < n; j++) {				if (num == result[j]) {					flag = false;					break;				}			}			if (flag) {				result[count] = num;				count++;			}		}		return result;	}}