package com.jwzt.DB.common.pk;
// Generated by MyEclipse - Hibernate Tools

import java.io.Serializable;
import org.hibernate.*;
import org.hibernate.engine.Mapping;
import org.hibernate.engine.SessionImplementor;
import org.hibernate.id.IdentifierGenerator;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.*;

import com.jwzt.DB.common.HibernateSessionUtil;
import com.jwzt.DB.common.HibernateUtil;
import com.jwzt.common.AppTools;
import com.jwzt.common.Logger;
/**
 * Soms4PkMgr generated by MyEclipse - Hibernate Tools
 */
public class PKMgr implements Serializable, IdentifierGenerator		
{
    public static Integer getNextId(String sTableName)
    {
    	Integer nNextId = null;
    	Session session = HibernateUtil.currentSession();

 		try
 		{
 			synchronized("0")
			{
 				Transaction ts = session.beginTransaction();
 	 			Query query = session.createQuery("from com.jwzt.DB.common.pk.PKInfo where table_name='" + sTableName + "'");

 	 			List results = query.list();
 	 			Iterator it=results.iterator();
 	 			
 	 			if(it.hasNext())
 	 			{
 	 				PKInfo pkInfo = (PKInfo)it.next();
 	 				nNextId = pkInfo.getNext_pk_id();
 	 				
 	 				int n = nNextId.intValue();
 	 				n++;
 	 				pkInfo.setNext_pk_id(Integer.valueOf(n));
 	 				session.update(pkInfo);
 	 			}
 	 			
 	 			ts.commit();
			}
 			
 		}
 		catch (HibernateException e)
 		{
 			//System.out.println("获取主键：" + e.getMessage());
 			Logger.log("获取主键：" + e.getMessage(), 2);
 			throw new RuntimeException(e);
 		}
 		finally
 		{
 			HibernateUtil.closeSession();
 		}
    	
    	return nNextId;
    }
    
	/**
     * 从表coms4_pk_mgr中获取指定表的指定列的下一个Id指，然后增加指定的步长，再保存到表中
     * @param     sTableName表名(不区分大小写)
     * @param     nStep     步长
     * @param     nNumber   一次获取多少个Id
     * @return    -1 没有成功；非-1值表示成功获取下一个Id
     *
     * 备注：每次取Id只需要调一次这个函数，不需要原来把Id设置回去的操作。
     *       取出来的值直接可以使用，不需要加一了
     *       如果取多个值，从获取到的值开始使用，然后根据nStep自己往后取nNumber个
     */
    public static int getNextId(String sTableName, int nStep, int nNumber)
    {
        int nRet = -1;
        Session session = HibernateUtil.currentSession();
        Transaction ts = session.beginTransaction();
        
        //Session session = HibernateSessionUtil.currentSession();
        
        try
        {
        	//HibernateSessionUtil.beginTransaction();
        	synchronized("0")
			{
	        	Query query = session.createQuery("from com.jwzt.DB.common.pk.PKInfo where table_name='" + sTableName + "'");
	        	
	        	List results = query.list();
				Iterator it = results.iterator();
				
				if (it.hasNext())
				{
					PKInfo pkInfo = (PKInfo) it.next();
					nRet = pkInfo.getNext_pk_id();
	
					pkInfo.setNext_pk_id(nRet + nStep * nNumber);
					session.update(pkInfo);
				}
				ts.commit();
			}
        }
        catch (HibernateException e)
		{
			//System.out.println("获取主键：" + e.getMessage());
			Logger.log("获取主键：" + e.getMessage(), 2);
			ts.rollback();
			//HibernateSessionUtil.rollbackTransaction();
			nRet = -1;
		}
		finally
		{
			HibernateUtil.closeSession();
		}
		
        return nRet;
    }
    
    
	/**
     * 从表coms4_pk_mgr中获取指定表的指定列的下一个Id指，然后增加指定的步长，再保存到表中
     * @param     sTableName表名(不区分大小写)
     * @param     nStep     步长
     * @param     nNumber   一次获取多少个Id
     * @return    -1 没有成功；非-1值表示成功获取下一个Id
     *
     * 备注：每次取Id只需要调一次这个函数，不需要原来把Id设置回去的操作。
     *       取出来的值直接可以使用，不需要加一了
     *       如果取多个值，从获取到的值开始使用，然后根据nStep自己往后取nNumber个
     */
    
    public static int getNextId2(String sTableName, int nStep, int nNumber)
    {
        int nRet = -1;
        
        Session session = HibernateSessionUtil.currentSession();
        
        try
        {
        	HibernateSessionUtil.beginTransaction();
        	
        	Query query = session.createQuery("from com.jwzt.DB.common.pk.PKInfo where table_name='" + sTableName + "'");
        	
        	List results = query.list();
			Iterator it = results.iterator();
			
			if (it.hasNext())
			{
				PKInfo pkInfo = (PKInfo) it.next();
				nRet = pkInfo.getNext_pk_id();

				pkInfo.setNext_pk_id(nRet + nStep * nNumber);
				session.update(pkInfo);
			}
        }
        catch (HibernateException e)
		{
			//System.out.println("获取主键：" + e.getMessage());
			Logger.log("获取主键：" + e.getMessage(), 2);
			HibernateSessionUtil.rollbackTransaction();
			nRet = -1;
		}
		finally
		{
			//HibernateUtil.closeSession();
		}
		
        return nRet;
    }
    
    
    public Serializable generate(SessionImplementor session, Object obj) throws HibernateException
    {
    	Integer retId = new Integer(2);
    	
    	//System.out.println(session.getFetchProfile());
    	//System.out.println("类名称："+session.bestGuessEntityName(obj));
    	Logger.log("类名称："+session.bestGuessEntityName(obj), 2);
    	//System.out.println(session.guessEntityName(obj));
    	
    	try
    	{
    		//System.out.println("数据库名称："+session.connection().getCatalog());
    		//System.out.println("实体名称："+session.getFactory().getCurrentSession().getEntityName(obj));
    		
    		//System.out.println(session.getContextEntityIdentifier(obj));
    		Logger.log("数据库名称："+session.connection().getCatalog(), 2);
    		Logger.log("实体名称："+session.getFactory().getCurrentSession().getEntityName(obj), 2);
    		Logger.log(session.getContextEntityIdentifier(obj).toString(), 2);
    	}catch (Exception e)
    	{
    		
    	}
    	retId = getNextId("soms4_vod_catalog");
    	return retId;
    }
	/**
	 * 从表cms_pk_mgr中获取指定表的指定列的下一个Id指，然后增加指定的步长，再保存到表中
	 * 
	 * @param conn
	 *            数据库连接
	 * @param sTableName表名(不区分大小写)
	 * @param sColName
	 *            列名(不区分大小写)
	 * @param nStep
	 *            步长
	 * @param nNumber
	 *            一次获取多少个Id
	 * @return -1 没有成功；非-1值表示成功获取下一个Id
	 * 
	 * 备注：每次取Id只需要调一次这个函数，不需要原来把Id设置回去的操作。 取出来的值直接可以使用，不需要加一了
	 * 如果取多个值，从获取到的值开始使用，然后根据nStep自己往后取nNumber个
	 */
	public static int getCmsNextId(Connection conn, String sTableName, String sColName, int nStep, int nNumber) {
		int nRet = -1;
		boolean bCloseConn = false;// 如果是自己打开的连接就要关闭连接，否则不关闭
		if (sTableName == null || sColName == null || nStep < 1 || nNumber < 1) {
			return nRet;
		}
		try {
			sTableName = sTableName.toLowerCase();
			sColName = sColName.toLowerCase();

			StringBuffer sSqlLock = new StringBuffer(512);
			sSqlLock.append("update cms_pk_mgr set next_pk_id=next_pk_id where lower(table_name) = '");
			sSqlLock.append(sTableName).append("' and lower(column_name)='").append(sColName).append("'");

			StringBuffer sSqlGetMax = new StringBuffer(512);
			sSqlGetMax.append("select next_pk_id from cms_pk_mgr where lower(table_name) = '");
			sSqlGetMax.append(sTableName).append("' and lower(column_name) = '").append(sColName).append("'");

			StringBuffer sSqlSetMax = new StringBuffer(512);

			if (!conn.getAutoCommit()) {
				conn = com.jwzt.DB.common.AppGlobal.getConn();
				bCloseConn = true;
			}
			java.sql.Statement stmt = null;
			java.sql.ResultSet rs = null;
			try {
				// 打开事务
				AppTools.setAutoCommit(conn, false);
				// 为了防止冲突,先执行一句没有意义的SQL语句，把表锁住
				stmt = conn.createStatement();
				stmt.executeUpdate(sSqlLock.toString());
				// 取可用值
				rs = stmt.executeQuery(sSqlGetMax.toString());
				if ((rs != null) && (rs.next())) {
					int nMaxid = rs.getInt("next_pk_id");
					sSqlSetMax.append("update cms_pk_mgr set next_pk_id=");
					sSqlSetMax.append(nMaxid + nStep * nNumber);
					sSqlSetMax.append(" where lower(table_name) = '").append(sTableName);
					sSqlSetMax.append("' and lower(column_name)='").append(sColName).append("'");
					stmt.executeUpdate(sSqlSetMax.toString());
					nRet = nMaxid;
				} else {
					AppTools.rollback(conn);
				}
			} catch (Exception e) {
				AppTools.rollback(conn);
			} finally {
				AppTools.commit(conn);
				AppTools.setAutoCommit(conn, true);

				if (rs != null) {
					AppTools.closeResultSet(rs);
					rs = null;
				}

				if (stmt != null) {
					AppTools.closeStatement(stmt);
					stmt = null;
				}

				if (bCloseConn) {
					if (conn != null) {
						AppTools.closeConnection(conn);
						conn = null;
					}
				}
			}
		} catch (Exception e) {
			// e.printStackTrace();
			nRet = -1;
		}
		return nRet;
	}
}
